use "std/types.jam";
use "std/array.jam";
-- use "std/iter.jam";
use "std/string.jam";
use "vec2.jam";

let g = love.graphics;
let y_off = FONT_SIZE / 2;
CHARS = " .'^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";

prototype textGrid {
    constructor: (x: number = 0, y: number = 0,
        w: number = 100, h: number = 100,
        chars_x: number = 10, chars_y: number = 10, scale: number = 1) :=>{
        
        @ar = [];
        for i in range chars_y, {
            @ar:push([]);
            for j in range chars_x, @ar#i:push(0);
        };
        @origin = vec2(x, y);
        @grid_size = vec2(chars_x, chars_y);
        @draw_size = vec2(w, h);
        @scale = scale;
    };

    draw: () :=> {
        g.rectangle("line", @origin.x - 2, @origin.y - (@scale * y_off),
            (@draw_size + vec2(4, @scale *y_off)):split!);

        g.push!;
        g.translate(@origin:split!);
        g.scale(@scale, @scale);
        let step = @draw_size / (@grid_size * @scale);

        for i in range @grid_size.y, {
            g.push!;
            for j in range @grid_size.x, {
                let n = math.floor ((len CHARS - 1) * @ar#i#j) + 1;
                g.print(CHARS:sub(n,n), FONT_SIZE / 8, -y_off);
                g.translate(step.x, 0);
            };
            g.pop!;
            g.translate(0, step.y);
        };
        g.pop!;
    };


    write: (pos: vec2, val: number, r: number = 1, mode: string = "write") :=> {
        let points = @get_points(pos, r);

        for p in points:iter!, @assign(p, val, mode);
    };

    assign: (pos: vec2, val: number, mode: string = "write") :=> {
        pos = (pos - @origin) * @grid_size / @draw_size;
        if !pos:within @grid_size || !pos:exceeds vec2.zero, => nil;

        let x, y = pos:floor!:split!;
        -- print("setting value ${val} at position ${pos}");
        match {
            mode == "write" => @ar#y#x = val;
            mode == "add" => @ar#y#x = @ar#y#x + val;
            mode == "mult" => @ar#y#x = @ar#y#x * val;
        };
    };

    get_points: (pos: vec2, r: number = 1) :=> {
        let points = [];
        points:push pos;
        points:concat @ripple(pos, r, pos, @grid_size / @draw_size, 0);
        => points;
    };

    ripple: (origin: vec2, r: number, pos: vec2, dir: vec2, reach: number) :=> {
        let points = [];
        let ar = [];
        pos = pos + dir;
        ar:push pos;
        for i in range reach, {
            ar:push(pos - (vec2.right * dir));
            ar:push(pos - (vec2.up * dir));
        };

        for v in ar:iter!, {
            if (v - origin):square_magnitude! < (r * r), points:push v;
        };
        if len points < 1, => [];

        => points:concat position_helper(origin, r, pos, dir, reach + 1);
    };

    __tostring: () :=> {
        let s = "";
        for i in range @grid_size.y, {
            s = s .. "\n";
            for j in range @grid_size.x, {
                let n = math.floor ((len CHARS - 1) * @ar#i#j) + 1;
                s = s .. CHARS:sub(n, n);
            };
        };
        => s;
    };
};
export textGrid;