-- C:/Misc_languages/jammy/std/string.jam - GENERATED 2021-11-12, 9:54:12 p.m.
-- JAMMY BOILERPLATE
local __require_params = (...);if not __require_params then error("Cannot run this module because it was not compiled as an entry point.") end;local __parent_dir = __require_params:match("(.-)[^%.]+$"):gsub("%.", "/");local function import(path) return require(path_join(__parent_dir, path):gsub("/", ".")) end;local exports={};__env = {};setmetatable(__env, { __index = _G });
-- END JAMMY BOILERPLATE
local number, iter, reduce, table_mt = __import(4, {number, iter, reduce, table_mt}, require(path_join(__root_dir, "std/iter"):gsub("/", ".")));__env.number, __env.iter, __env.reduce, __env.table_mt = number, iter, reduce, table_mt;debug.setmetatable(0, { __index = function(t, k) return __env.number[k] end });
local __match_type, __typecheck, __typecheck_arg, __typecheck_arg_optional, __typecheck_arg_union, __typecheck_arg_union_optional, types, type_advanced, typechecks = __import(9, {__match_type, __typecheck, __typecheck_arg, __typecheck_arg_optional, __typecheck_arg_union, __typecheck_arg_union_optional, types, type_advanced, typechecks}, require(path_join(__root_dir, "std/types"):gsub("/", ".")));__env.__match_type, __env.__typecheck, __env.__typecheck_arg, __env.__typecheck_arg_optional, __env.__typecheck_arg_union, __env.__typecheck_arg_union_optional, __env.types, __env.type_advanced, __env.typechecks = __match_type, __typecheck, __typecheck_arg, __typecheck_arg_optional, __typecheck_arg_union, __typecheck_arg_union_optional, types, type_advanced, typechecks;
local string_metatable;string_metatable = function() return getmetatable("") end;
local string_mt = { ["char_at"] = function(self, i) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, i, "number");return self:sub(i, i) end, ["__index"] = function(self, key) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, key, "exists");print("AAAA");
do return (function() if (type(key)=="number") then return self:sub(key, key) else if (key=="length") then return self:len() else return self[key] end end end)() end end, ["substring"] = string.sub, ["slice"] = string.sub, ["concat"] = function(a, b) __typecheck_arg(typechecks, 1, a, "string");__typecheck_arg(typechecks, 2, b, "string");return (a..b) end, ["contains"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return bool(self:find(str, 1, true)) end, ["index_of"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return (tbl(self:find(str, 1, true)))[1] end, ["last_index_of"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return ((1+self:len())-self:reverse():index_of(str)) end, ["ends_with"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return (self:sub(-(str:len()), -(1))==str) end, ["starts_with"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return (self:sub(1, str:len())==str) end, ["match_all"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return table.from_iterator(self:gmatch(str)) end, ["pad_left"] = function(self, total_length, char) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
char = char == nil and (" ") or char;__typecheck_arg(typechecks, 1, total_length, "number");__typecheck_arg(typechecks, 2, char, "string");return (char:repeat_times((total_length-self:len()))..self) end, ["pad_right"] = function(self, total_length, char) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
char = char == nil and (" ") or char;__typecheck_arg(typechecks, 1, total_length, "number");__typecheck_arg(typechecks, 2, char, "string");return (self..char:repeat_times((total_length-self:len()))) end, ["repeat_times"] = function(self, n) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, n, "number");return reduce("", tbl(range_inc(n)), function(s) return (s..self) end) end, ["escape_match"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
return (tbl(self:gsub("[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1")))[1] end, ["replace_first"] = function(self, original, replacement) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, original, "string");__typecheck_arg(typechecks, 2, replacement, "string");return (tbl(self:gsub(original:escape_match(), replacement, 1)))[1] end, ["replace_all"] = function(self, original, replacement) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, original, "string");__typecheck_arg(typechecks, 2, replacement, "string");return self:gsub(original:escape_match(), replacement) end, ["count_instances"] = function(self, str) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, str, "string");return select(2, self:gsub(str:escape_match(), str:escape_match())) end, ["split"] = function(self, separator) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
__typecheck_arg(typechecks, 1, separator, "string");local t = {  };
local i = self:index_of(separator);
while (i and ((i<((self:len()+1))))) do do t[((#(t)+1))] = self:slice(0, (i-1));
self = self:slice((i+separator:len()));
i = self:index_of(separator);
end end;
t[((#(t)+1))] = self;
do return t end end, ["trim_left"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
return self:match("^%s*(.-)$") end, ["trim_right"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
return self:match("^(.-)%s*$") end, ["trim"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
return self:match("^%s*(.-)%s*$") end, ["chars"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
return reduce({  }, tbl(range_inc(self:len())), function(t, i) t[i] = self:sub(i, i) end) end, ["iter"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
local i, n = 0, self:len();
do return function() i = (i+1);
if (i<=n) then do return self:sub(i, i) end end end end end, ["ipairs"] = function(self) if not has_metatable(self, (string_metatable())) then error("bad argument 'self' to " .. debug.getinfo(1, 'nl').name .. " (got " .. type(self) .. ")", 2) end;
local i, n = 0, self:len();
do return function() i = (i+1);
if (i<=n) then do return i, self:sub(i, i) end end end end end };
exports[1] = string_mt -- to be imported as 'string';
 return exports;